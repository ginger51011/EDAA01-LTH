package mountain;

import java.util.HashMap;

import fractal.Fractal;
import fractal.TurtleGraphics;
import mountain.RandomUtilities;

public class Mountain extends Fractal {
	// Startpunkter
	private Point a;
	private Point b;
	private Point c;
	private HashMap<Side, Point> hm;
	
	public Mountain(Point a, Point b, Point c) {
		super();
		this.a = a;
		this.b = b;
		this.c = c;
		hm = new HashMap<Side, Point>();
	}

	@Override
	public String getTitle() {
		return "Mountain";
	}

	@Override
	public void draw(TurtleGraphics t) {
		double dev = 20.0;
		fractalLine(t, order, a, b, c, dev);
	}
	
	/* 
	 * Recursive method: Draws a recursive line of the triangle. 
	 */
	public void fractalLine(TurtleGraphics t, int order, Point a, Point b, Point c, double dev) {
		if (order == 0) {
			t.moveTo(a.getX(), a.getY());
			t.penDown();
			t.forwardTo(b.getX(), b.getY());
			t.forwardTo(c.getX(), c.getY());
			t.forwardTo(a.getX(), a.getY());
			t.penUp();
		} else {
			Side ab = new Side(a, b);
			Side ac = new Side(a, c);
			Side bc = new Side(b, c);
			// D4 - creates midpoints
			Point midAB = midPoint(a, b, dev);
			Point midAC = midPoint(a, c, dev);
			Point midBC = midPoint(b, c, dev);
			
			fractalLine(t, order - 1, a, midAB, midAC, dev / 2);
			fractalLine(t, order - 1, b, midAB, midBC, dev / 2);
			fractalLine(t, order - 1, c, midAC, midBC, dev / 2);
			fractalLine(t, order - 1, midAB, midAC, midBC, dev / 2);
		}
	}
	
	/* 
	 * Hittar punkten mellan tv√• andra punkter
	 */
	private Point midPoint(Point a, Point b, double dev) {
		Side s = new Side(a, b);
		Point mp;
		if (hm.containsKey(s)) {
			mp = hm.get(s);
			hm.remove(s);
		} else {
			int newX = (a.getX() + b.getX()) / 2;
			int newY = (a.getY() + b.getY()) / 2;
			mp = new Point (newX, newY + (int) RandomUtilities.randFunc(dev));
			hm.put(s, mp);
		}
 		return mp;
	}
}
